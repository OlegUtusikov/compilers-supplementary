-- Stack machine.

import List;
import World;
import State;
import Expr;
import Buffer;
import Fun;

-- Stack code printer. Takes a list of SM instructions, return its
-- string representation.
public fun showSMInsn(i) {
  case i of
    READ -> sprintf("READ")
    | WRITE -> sprintf("WRITE")
    | BINOP (s) -> sprintf("BINOP %s", s)
    | LD    (x) -> sprintf("LD %s", x)
    | ST    (x) -> sprintf("ST %s", x)
    | CONST (n) -> sprintf("CONST %d", n)
  esac
}

public fun showSM(prg) {
  map(fun (i) { showSMInsn(i) ++ "\n" }, prg).stringcat
}

fun evalInstraction([stack, state, world], instruction) {
  case instruction of
    CONST(value) -> [value:stack, state, world]
    | BINOP(op) -> case stack of
      right:left:tail -> [evalBinaryOperation(op, left, right):tail, state, world]
      | _ -> failure("Bad binary operation\n")
    esac
    | LD(name) -> [state(name):stack, state, world]
    | ST(name) -> case stack of
      value:tail -> [tail, state <- [name, value], world]
      | _ -> failure("Can't store value into var: %s\n", name)
    esac
    | READ -> (
      var t = readWorld(world);
      [t.fst:stack, state, t.snd]
    )
    | WRITE -> case stack of
      value:tail -> [tail, state, writeWorld(value, world)]
      | _ -> failure("Can't write value\n")
    esac
    | _ -> failure("Bad instruction\n")
  esac
}

-- Stack machine interpreter. Takes an SM-configuration and a program,
-- returns a final configuration
fun eval(configuration, instructions) {
  case instructions of
    i:tail -> eval(evalInstraction(configuration, i), tail)
    | {} -> configuration
  esac
}

-- Runs a stack machine for a given input and a given program, returns an output
public fun evalSM(input, instructions) {
  eval([{ }, emptyState, createWorld(input)], instructions)[2].getOutput
}

-- Compiles an expression into a stack machine code.
-- Takes an expression, returns a list of stack machine instructions
fun compileExpr(expr) {
  case expr of
    Var(name) -> { LD(name) }
    | Const(value) -> { CONST(value) }
    | Binop(op, left, right) -> compileExpr(left) +++ compileExpr(right) +++ { BINOP(op) }
  esac
}

-- Compiles a statement into a stack machine code.
-- Takes a statement, returns a list of stack machine
-- instructions.
public fun compileSM(statement) {
  case statement of
    Skip -> []
    | Assn(name, expr) -> compileExpr(expr) +++ { ST(name) }
    | Seq(left, right) -> compileSM(left) +++ compileSM(right)
    | Read(name) -> { READ, ST(name) }
    | Write(expr) -> compileExpr(expr) +++ { WRITE }
  esac
}