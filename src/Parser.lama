-- Parser 

import Ostap;
import Lexer;
import List;
import Fun;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr(left, parser, right) {
  syntax (-left parser -right)
}

-- Primary expression
var primary = memo $ eta syntax (
  constant = decimal { Const(stringInt(constant)) } |
  variable = lident  { Var(variable) }              |
  inbr[s("("), exp, s(")")]
);

fun binMapper(opName) {
  [s(opName), fun (left, _, right) { Binop(opName, left, right) }]
}

var exp = memo $ eta (expr({
  [Left, {binMapper("!!")}],
  [Left, {binMapper("&&")}],
  [Nona, map(binMapper, {"<", ">", "<=", ">=", "==", "!="})],
  [Left, map(binMapper, {"+", "-"})],
  [Left, map(binMapper, {"*", "/", "%"})]
}, primary));

var stmt = memo $ eta syntax (
  kSkip { Skip } |
  kRead variable = inbr[s("("), lident, s(")")] { Read(variable) } |
  kWrite value = inbr[s("("), exp, s(")")] { Write(value) } |
  variable = lident s[":="] value = exp { Assn(variable, value) }),
  code = memo $ eta syntax (stmt | line = stmt s[";"] tail = code {Seq(line, tail)});


-- Public top-level parser
public parse = code;

